{"ast":null,"code":"/*\nBreath of the Compassionate is the name of an ancient Islamic geometric tesselation\nYou can look at it as a series of diagonal squares, where one half of them are \nexpanding outwards while the other half contract.\nIt is a study in balance, give and take.\nI also added generative elements to keep it interesting: you can press any key to \nrandomly change the color gradient, and different stars are skipped each time\nto encourage you to explore the space\n*/\n\nlet skipped_cells = [];\nfunction setup() {\n\n  //   createCanvas(3000, 3000);\n  //   // drawingContext.shadowOffsetX = 5;\n  //   // drawingContext.shadowOffsetY = -5;\n  //   // drawingContext.shadowBlur = 10;\n  //   // drawingContext.shadowColor = \"black\";\n  //   colorMode(HSB); \n\n  //   //randomly delete some of the stars \n  //   for(let i=0; i<75; i++) {\n  //     skipped_cells[i] = [[floor(Math.random()*20), floor(Math.random()*20)], floor(Math.random()*7+1)];\n  //   }\n}\nlet base_size = 150,\n  size_change = 0,\n  inhaling = true,\n  paused = false;\nlet lerp_color1,\n  lerp_color2,\n  color1 = 0,\n  color2 = 1,\n  color3 = 2,\n  color4 = 3;\nfunction draw(p5) {\n  p5.background(\"white\");\n  p5.noStroke();\n  let elements = {\n    water: p5.color(212, 44, 100),\n    fire: p5.color(4, 68, 100),\n    earth: p5.color(130, 65, 68),\n    air: p5.color(304, 8, 100)\n  };\n  if (!paused) {\n    if (size_change >= 65 || size_change <= -42) {\n      inhaling = !inhaling;\n    }\n    let gradient_position = p5.map(Math.abs(size_change), 0, 65, 0, 1);\n    if (inhaling) {\n      size_change += 2;\n    } else {\n      size_change -= 2;\n    }\n    lerp_color1 = p5.lerpColor(Object.entries(elements)[color1][1], Object.entries(elements)[color2][1], gradient_position);\n    lerp_color2 = p5.lerpColor(Object.entries(elements)[color3][1], Object.entries(elements)[color4][1], gradient_position);\n  }\n  tesselation(p5, base_size / 2, base_size / 2, base_size + size_change);\n  p5.fill(\"blue\");\n  star(p5, 200, 200, 80);\n}\nfunction mousePressed() {\n  paused = !paused;\n}\nfunction keyPressed() {\n  color1 = Math.floor(Math.random() * 4);\n  color2 = Math.floor(Math.random() * 4);\n  color3 = Math.floor(Math.random() * 4);\n  color4 = Math.floor(Math.random() * 4);\n  while (color1 === color2) {\n    color1 = Math.floor(Math.random() * 4);\n    color2 = Math.floor(Math.random() * 4);\n  }\n}\nfunction tesselation(p5, x, y, size) {\n  let centerX = x,\n    centerY = y;\n  for (let i = 0; i < 20; i++) {\n    for (let j = 0; j < 20; j++) {\n      p5.fill(lerp_color1);\n      star(p5, centerX, centerY, size / 2);\n      p5.fill(\"black\");\n      star(p5, centerX, centerY, size / 2.65);\n      //   if (skip !== 5) {\n      //     p5.fill(lerp_color2);\n      //     inverted_star(p5, centerX+base_size/2, centerY+base_size/2, (base_size-size_change)/5);\n      //   }\n      //   if (skip !== 6) {\n      //     p5.fill(\"black\");\n      //     inverted_star(p5, centerX+base_size/2, centerY+base_size/2, (base_size-size_change)/10);\n      //   }\n      //   if (skip !== 7) {\n      //     p5.fill(lerp_color2);\n      //     inverted_star(p5, centerX+base_size/2, centerY+base_size/2, (base_size-size_change)/20);\n      //   }\n      centerX += base_size;\n    }\n    centerX = x;\n    centerY += base_size;\n  }\n}\nfunction star(p5, centerX, centerY, size) {\n  let angle = p5.TWO_PI / 16;\n  p5.beginShape();\n  let x, y;\n  for (let i = 0; i < 16; i++) {\n    if (i % 4 === 0) {\n      x = centerX + base_size / 2 * Math.cos(i * angle);\n      y = centerY + base_size / 2 * Math.sin(i * angle);\n    } else if (i % 2 === 0) {\n      x = centerX + (size + size_change > base_size / 2 ? base_size / 2 : size + size_change) * Math.cos(i * angle);\n      y = centerY + (size + size_change > base_size / 2 ? base_size / 2 : size + size_change) * Math.sin(i * angle);\n    } else {\n      x = centerX + 0.765 * size * Math.cos(i * angle);\n      y = centerY + 0.765 * size * Math.sin(i * angle);\n    }\n    p5.vertex(x, y);\n  }\n  p5.endShape(p5.CLOSE);\n}\nfunction inverted_star(p5, centerX, centerY, size) {\n  let angle = p5.TWO_PI / 16;\n  p5.beginShape();\n  let x, y;\n  for (let i = 0; i < 16; i++) {\n    if (i % 4 === 0) {\n      x = centerX + base_size / 2 * Math.cos(i * angle);\n      y = centerY + base_size / 2 * Math.sin(i * angle);\n    } else if (i % 2 === 0) {\n      let magnitude = size - size_change > base_size / 2 ? base_size / 2 : size - size_change;\n      if (magnitude < -30) {\n        magnitude = -30;\n      }\n      x = centerX + magnitude * Math.cos(i * angle);\n      y = centerY + magnitude * Math.sin(i * angle);\n    } else {\n      x = centerX + 0.765 * size * Math.cos(i * angle);\n      y = centerY + 0.765 * size * Math.sin(i * angle);\n    }\n    p5.vertex(x, y);\n  }\n  p5.endShape(p5.CLOSE);\n}\nexport { draw, setup, mousePressed, keyPressed };","map":{"version":3,"names":["skipped_cells","setup","base_size","size_change","inhaling","paused","lerp_color1","lerp_color2","color1","color2","color3","color4","draw","p5","background","noStroke","elements","water","color","fire","earth","air","gradient_position","map","Math","abs","lerpColor","Object","entries","tesselation","fill","star","mousePressed","keyPressed","floor","random","x","y","size","centerX","centerY","i","j","angle","TWO_PI","beginShape","cos","sin","vertex","endShape","CLOSE","inverted_star","magnitude"],"sources":["/Users/katieadamsky/katie-adamsky.github.io/site/src/pages/projects/breath/sketch.js"],"sourcesContent":["/*\nBreath of the Compassionate is the name of an ancient Islamic geometric tesselation\nYou can look at it as a series of diagonal squares, where one half of them are \nexpanding outwards while the other half contract.\nIt is a study in balance, give and take.\nI also added generative elements to keep it interesting: you can press any key to \nrandomly change the color gradient, and different stars are skipped each time\nto encourage you to explore the space\n*/\n\nlet skipped_cells = [];\nfunction setup() {\n\n//   createCanvas(3000, 3000);\n//   // drawingContext.shadowOffsetX = 5;\n//   // drawingContext.shadowOffsetY = -5;\n//   // drawingContext.shadowBlur = 10;\n//   // drawingContext.shadowColor = \"black\";\n//   colorMode(HSB); \n\n//   //randomly delete some of the stars \n//   for(let i=0; i<75; i++) {\n//     skipped_cells[i] = [[floor(Math.random()*20), floor(Math.random()*20)], floor(Math.random()*7+1)];\n//   }\n}\n\nlet base_size = 150, size_change = 0, inhaling = true, paused = false;\nlet lerp_color1, lerp_color2, color1 = 0, color2 = 1, color3 = 2, color4 = 3;\n\nfunction draw(p5) {\n  p5.background(\"white\"); \n  p5.noStroke();\n  let elements = {\n    water: p5.color(212, 44, 100), \n    fire: p5.color(4, 68, 100), \n    earth: p5.color(130, 65, 68), \n    air: p5.color(304, 8, 100),\n  }\n  \n  if (!paused) {\n    if (size_change >= 65 || size_change <= -42) {\n      inhaling = !inhaling;\n    }\n    let gradient_position = p5.map(Math.abs(size_change), 0, 65, 0, 1);\n    if (inhaling) {\n      size_change += 2;\n    } else {\n      size_change -= 2;\n    }\n    lerp_color1 = p5.lerpColor(Object.entries(elements)[color1][1], Object.entries(elements)[color2][1], gradient_position);\n    lerp_color2 = p5.lerpColor(Object.entries(elements)[color3][1], Object.entries(elements)[color4][1], gradient_position);\n  }\n  tesselation(p5, base_size/2, base_size/2, base_size + size_change);\n  p5.fill(\"blue\");\n  star(p5, 200, 200, 80);\n}\n\nfunction mousePressed() {\n  paused = !paused;\n}\n\nfunction keyPressed() {\n  color1 = Math.floor(Math.random()*4);\n  color2 = Math.floor(Math.random()*4);\n  color3 = Math.floor(Math.random()*4);\n  color4 = Math.floor(Math.random()*4);\n  while(color1===color2){\n    color1 = Math.floor(Math.random()*4);\n    color2 = Math.floor(Math.random()*4);\n  }\n}\n\nfunction tesselation(p5, x, y, size) {\n  let centerX = x, centerY = y;\n  for(let i=0; i < 20; i++) {\n    for(let j=0; j < 20; j++) {\n        p5.fill(lerp_color1);\n        star(p5, centerX, centerY, size/2);\n        p5.fill(\"black\");\n        star(p5, centerX, centerY, size/2.65);\n    //   if (skip !== 5) {\n    //     p5.fill(lerp_color2);\n    //     inverted_star(p5, centerX+base_size/2, centerY+base_size/2, (base_size-size_change)/5);\n    //   }\n    //   if (skip !== 6) {\n    //     p5.fill(\"black\");\n    //     inverted_star(p5, centerX+base_size/2, centerY+base_size/2, (base_size-size_change)/10);\n    //   }\n    //   if (skip !== 7) {\n    //     p5.fill(lerp_color2);\n    //     inverted_star(p5, centerX+base_size/2, centerY+base_size/2, (base_size-size_change)/20);\n    //   }\n      centerX += base_size;\n    }\n    centerX = x;\n    centerY += base_size;\n  }\n\n}\n\n\n\nfunction star(p5, centerX, centerY, size) {\n  let angle = p5.TWO_PI / 16; \n  p5.beginShape();\n  let x, y;\n  for (let i = 0; i < 16; i++) {\n    if (i%4 === 0) {\n      x = centerX + (base_size/2) * Math.cos(i * angle);\n      y = centerY + (base_size/2) * Math.sin(i * angle);\n    } else if (i%2 === 0) {\n      x = centerX + (size+size_change > (base_size /2) ? (base_size/2) : (size+size_change)) * Math.cos(i * angle);\n      y = centerY + (size+size_change > (base_size/2) ? (base_size/2) : (size+size_change)) * Math.sin(i * angle);\n    } else {\n      x = centerX + 0.765 * (size) * Math.cos(i * angle);\n      y = centerY + 0.765 * size * Math.sin(i * angle);\n    }\n    p5.vertex(x, y);\n  }\n  p5.endShape(p5.CLOSE);\n}\n\nfunction inverted_star(p5, centerX, centerY, size) {\n  let angle = p5.TWO_PI / 16; \n  p5.beginShape();\n  let x, y;\n  for (let i = 0; i < 16; i++) {\n    if (i%4 === 0) {\n      x = centerX + (base_size/2) * Math.cos(i * angle);\n      y = centerY + (base_size/2) * Math.sin(i * angle);\n    } else if (i%2 === 0) {\n      let magnitude = (size-size_change > (base_size /2) ? (base_size/2) : (size-size_change));\n      if (magnitude < -30) {\n        magnitude = -30;\n      }\n      x = centerX + magnitude * Math.cos(i * angle);\n      y = centerY + magnitude * Math.sin(i * angle);\n    } else {\n      x = centerX + 0.765 * (size) * Math.cos(i * angle);\n      y = centerY + 0.765 * size * Math.sin(i * angle);\n    }\n    p5.vertex(x, y);\n  }\n  p5.endShape(p5.CLOSE);\n}\n\n\nexport {draw, setup, mousePressed, keyPressed} \n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}