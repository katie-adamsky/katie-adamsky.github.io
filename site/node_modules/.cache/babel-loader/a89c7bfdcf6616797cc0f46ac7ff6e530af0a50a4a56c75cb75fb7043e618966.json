{"ast":null,"code":"/*\nBreath of the Compassionate is the name of an ancient Islamic geometric tesselation\nYou can look at it as a series of diagonal squares, where one half of them are \nexpanding outwards while the other half contract.\nIt is a study in balance, give and take.\nI also added generative elements to keep it interesting: you can press any key to \nrandomly change the color gradient, and different stars are skipped each time\nto encourage you to explore the space\n*/\n\nlet skipped_cells = [];\nfunction setup() {\n\n  //   createCanvas(3000, 3000);\n  //   // drawingContext.shadowOffsetX = 5;\n  //   // drawingContext.shadowOffsetY = -5;\n  //   // drawingContext.shadowBlur = 10;\n  //   // drawingContext.shadowColor = \"black\";\n  //   colorMode(HSB); \n\n  //   //randomly delete some of the stars \n  //   for(let i=0; i<75; i++) {\n  //     skipped_cells[i] = [[floor(Math.random()*20), floor(Math.random()*20)], floor(Math.random()*7+1)];\n  //   }\n}\nlet base_size = 150,\n  size_change = 0,\n  inhaling = true,\n  paused = false;\nlet lerp_color1,\n  lerp_color2,\n  color1 = 0,\n  color2 = 1,\n  color3 = 2,\n  color4 = 3;\nfunction draw(p5) {\n  p5.background(\"white\");\n  p5.noStroke();\n  let elements = {\n    water: p5.color(212, 44, 100),\n    fire: p5.color(4, 68, 100),\n    earth: p5.color(130, 65, 68),\n    air: p5.color(304, 8, 100)\n  };\n  // Draw a rectangle\n  fill(255, 0, 0); // Set fill color to red\n  rect(50, 50, 100, 50); // x, y, width, height\n\n  // Draw an ellipse\n  fill(0, 0, 255); // Set fill color to blue\n  ellipse(200, 200, 80, 80); // x, y, width, height\n  //   if (!paused) {\n  //     if (size_change >= 65 || size_change <= -42) {\n  //       inhaling = !inhaling;\n  //     }\n  //     let gradient_position = p5.map(Math.abs(size_change), 0, 65, 0, 1);\n  //     if (inhaling) {\n  //       size_change += 2;\n  //     } else {\n  //       size_change -= 2;\n  //     }\n  //     lerp_color1 = p5.lerpColor(Object.entries(elements)[color1][1], Object.entries(elements)[color2][1], gradient_position);\n  //     lerp_color2 = p5.lerpColor(Object.entries(elements)[color3][1], Object.entries(elements)[color4][1], gradient_position);\n  //   }\n  //tesselation(p5, base_size/2, base_size/2, base_size + size_change);\n  p5.fill(elements[\"water\"]);\n  star(p5, base_size / 2, base_size / 2, base_size);\n}\nfunction mousePressed() {\n  paused = !paused;\n}\nfunction keyPressed() {\n  color1 = Math.floor(Math.random() * 4);\n  color2 = Math.floor(Math.random() * 4);\n  color3 = Math.floor(Math.random() * 4);\n  color4 = Math.floor(Math.random() * 4);\n  while (color1 === color2) {\n    color1 = Math.floor(Math.random() * 4);\n    color2 = Math.floor(Math.random() * 4);\n  }\n}\nfunction tesselation(p5, x, y, size) {\n  let centerX = x,\n    centerY = y;\n  for (let i = 0; i < 20; i++) {\n    for (let j = 0; j < 20; j++) {\n      p5.fill(lerp_color1);\n      star(p5, centerX, centerY, size / 2);\n      p5.fill(\"black\");\n      star(p5, centerX, centerY, size / 2.65);\n      //   if (skip !== 5) {\n      //     p5.fill(lerp_color2);\n      //     inverted_star(p5, centerX+base_size/2, centerY+base_size/2, (base_size-size_change)/5);\n      //   }\n      //   if (skip !== 6) {\n      //     p5.fill(\"black\");\n      //     inverted_star(p5, centerX+base_size/2, centerY+base_size/2, (base_size-size_change)/10);\n      //   }\n      //   if (skip !== 7) {\n      //     p5.fill(lerp_color2);\n      //     inverted_star(p5, centerX+base_size/2, centerY+base_size/2, (base_size-size_change)/20);\n      //   }\n      centerX += base_size;\n    }\n    centerX = x;\n    centerY += base_size;\n  }\n}\nfunction star(p5, centerX, centerY, size) {\n  let angle = Math.TWO_PI / 16;\n  p5.beginShape();\n  let x, y;\n  for (let i = 0; i < 16; i++) {\n    if (i % 4 === 0) {\n      x = centerX + base_size / 2 * Math.cos(i * angle);\n      y = centerY + base_size / 2 * Math.sin(i * angle);\n    } else if (i % 2 === 0) {\n      x = centerX + (size + size_change > base_size / 2 ? base_size / 2 : size + size_change) * Math.cos(i * angle);\n      y = centerY + (size + size_change > base_size / 2 ? base_size / 2 : size + size_change) * Math.sin(i * angle);\n    } else {\n      x = centerX + 0.765 * size * Math.cos(i * angle);\n      y = centerY + 0.765 * size * Math.sin(i * angle);\n    }\n    p5.vertex(x, y);\n  }\n  p5.endShape(p5.CLOSE);\n}\nfunction inverted_star(p5, centerX, centerY, size) {\n  let angle = Math.TWO_PI / 16;\n  p5.beginShape();\n  let x, y;\n  for (let i = 0; i < 16; i++) {\n    if (i % 4 === 0) {\n      x = centerX + base_size / 2 * Math.cos(i * angle);\n      y = centerY + base_size / 2 * Math.sin(i * angle);\n    } else if (i % 2 === 0) {\n      let magnitude = size - size_change > base_size / 2 ? base_size / 2 : size - size_change;\n      if (magnitude < -30) {\n        magnitude = -30;\n      }\n      x = centerX + magnitude * Math.cos(i * angle);\n      y = centerY + magnitude * Math.sin(i * angle);\n    } else {\n      x = centerX + 0.765 * size * Math.cos(i * angle);\n      y = centerY + 0.765 * size * Math.sin(i * angle);\n    }\n    p5.vertex(x, y);\n  }\n  p5.endShape(p5.CLOSE);\n}\nexport { draw, setup, mousePressed, keyPressed };","map":{"version":3,"names":["skipped_cells","setup","base_size","size_change","inhaling","paused","lerp_color1","lerp_color2","color1","color2","color3","color4","draw","p5","background","noStroke","elements","water","color","fire","earth","air","fill","rect","ellipse","star","mousePressed","keyPressed","Math","floor","random","tesselation","x","y","size","centerX","centerY","i","j","angle","TWO_PI","beginShape","cos","sin","vertex","endShape","CLOSE","inverted_star","magnitude"],"sources":["/Users/katieadamsky/katie-adamsky.github.io/site/src/pages/projects/breath/sketch.js"],"sourcesContent":["/*\nBreath of the Compassionate is the name of an ancient Islamic geometric tesselation\nYou can look at it as a series of diagonal squares, where one half of them are \nexpanding outwards while the other half contract.\nIt is a study in balance, give and take.\nI also added generative elements to keep it interesting: you can press any key to \nrandomly change the color gradient, and different stars are skipped each time\nto encourage you to explore the space\n*/\n\nlet skipped_cells = [];\nfunction setup() {\n\n//   createCanvas(3000, 3000);\n//   // drawingContext.shadowOffsetX = 5;\n//   // drawingContext.shadowOffsetY = -5;\n//   // drawingContext.shadowBlur = 10;\n//   // drawingContext.shadowColor = \"black\";\n//   colorMode(HSB); \n\n//   //randomly delete some of the stars \n//   for(let i=0; i<75; i++) {\n//     skipped_cells[i] = [[floor(Math.random()*20), floor(Math.random()*20)], floor(Math.random()*7+1)];\n//   }\n}\n\nlet base_size = 150, size_change = 0, inhaling = true, paused = false;\nlet lerp_color1, lerp_color2, color1 = 0, color2 = 1, color3 = 2, color4 = 3;\n\nfunction draw(p5) {\n  p5.background(\"white\"); \n  p5.noStroke();\n  let elements = {\n    water: p5.color(212, 44, 100), \n    fire: p5.color(4, 68, 100), \n    earth: p5.color(130, 65, 68), \n    air: p5.color(304, 8, 100),\n  }\n    // Draw a rectangle\n    fill(255, 0, 0); // Set fill color to red\n    rect(50, 50, 100, 50); // x, y, width, height\n  \n    // Draw an ellipse\n    fill(0, 0, 255); // Set fill color to blue\n    ellipse(200, 200, 80, 80); // x, y, width, height\n//   if (!paused) {\n//     if (size_change >= 65 || size_change <= -42) {\n//       inhaling = !inhaling;\n//     }\n//     let gradient_position = p5.map(Math.abs(size_change), 0, 65, 0, 1);\n//     if (inhaling) {\n//       size_change += 2;\n//     } else {\n//       size_change -= 2;\n//     }\n//     lerp_color1 = p5.lerpColor(Object.entries(elements)[color1][1], Object.entries(elements)[color2][1], gradient_position);\n//     lerp_color2 = p5.lerpColor(Object.entries(elements)[color3][1], Object.entries(elements)[color4][1], gradient_position);\n//   }\n  //tesselation(p5, base_size/2, base_size/2, base_size + size_change);\n  p5.fill(elements[\"water\"]);\n  star(p5, base_size/2, base_size/2, base_size)\n}\n\nfunction mousePressed() {\n  paused = !paused;\n}\n\nfunction keyPressed() {\n  color1 = Math.floor(Math.random()*4);\n  color2 = Math.floor(Math.random()*4);\n  color3 = Math.floor(Math.random()*4);\n  color4 = Math.floor(Math.random()*4);\n  while(color1===color2){\n    color1 = Math.floor(Math.random()*4);\n    color2 = Math.floor(Math.random()*4);\n  }\n}\n\nfunction tesselation(p5, x, y, size) {\n  let centerX = x, centerY = y;\n  for(let i=0; i < 20; i++) {\n    for(let j=0; j < 20; j++) {\n        p5.fill(lerp_color1);\n        star(p5, centerX, centerY, size/2);\n        p5.fill(\"black\");\n        star(p5, centerX, centerY, size/2.65);\n    //   if (skip !== 5) {\n    //     p5.fill(lerp_color2);\n    //     inverted_star(p5, centerX+base_size/2, centerY+base_size/2, (base_size-size_change)/5);\n    //   }\n    //   if (skip !== 6) {\n    //     p5.fill(\"black\");\n    //     inverted_star(p5, centerX+base_size/2, centerY+base_size/2, (base_size-size_change)/10);\n    //   }\n    //   if (skip !== 7) {\n    //     p5.fill(lerp_color2);\n    //     inverted_star(p5, centerX+base_size/2, centerY+base_size/2, (base_size-size_change)/20);\n    //   }\n      centerX += base_size;\n    }\n    centerX = x;\n    centerY += base_size;\n  }\n\n}\n\n\n\nfunction star(p5, centerX, centerY, size) {\n  let angle = Math.TWO_PI / 16; \n  p5.beginShape();\n  let x, y;\n  for (let i = 0; i < 16; i++) {\n    if (i%4 === 0) {\n      x = centerX + (base_size/2) * Math.cos(i * angle);\n      y = centerY + (base_size/2) * Math.sin(i * angle);\n    } else if (i%2 === 0) {\n      x = centerX + (size+size_change > (base_size /2) ? (base_size/2) : (size+size_change)) * Math.cos(i * angle);\n      y = centerY + (size+size_change > (base_size/2) ? (base_size/2) : (size+size_change)) * Math.sin(i * angle);\n    } else {\n      x = centerX + 0.765 * (size) * Math.cos(i * angle);\n      y = centerY + 0.765 * size * Math.sin(i * angle);\n    }\n    p5.vertex(x, y);\n  }\n  p5.endShape(p5.CLOSE);\n}\n\nfunction inverted_star(p5, centerX, centerY, size) {\n  let angle = Math.TWO_PI / 16; \n  p5.beginShape();\n  let x, y;\n  for (let i = 0; i < 16; i++) {\n    if (i%4 === 0) {\n      x = centerX + (base_size/2) * Math.cos(i * angle);\n      y = centerY + (base_size/2) * Math.sin(i * angle);\n    } else if (i%2 === 0) {\n      let magnitude = (size-size_change > (base_size /2) ? (base_size/2) : (size-size_change));\n      if (magnitude < -30) {\n        magnitude = -30;\n      }\n      x = centerX + magnitude * Math.cos(i * angle);\n      y = centerY + magnitude * Math.sin(i * angle);\n    } else {\n      x = centerX + 0.765 * (size) * Math.cos(i * angle);\n      y = centerY + 0.765 * size * Math.sin(i * angle);\n    }\n    p5.vertex(x, y);\n  }\n  p5.endShape(p5.CLOSE);\n}\n\n\nexport {draw, setup, mousePressed, keyPressed} \n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}